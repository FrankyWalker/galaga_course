//Franky, make sure to see my comment on task9 issue before approving this.
//Also, doublecheck my explanantions here.

You'll be working in main.rs for this task.

Add the game_state module.

Import the GameState struct from the game_state module with the use key
word. If you forgot how to do that, here is a section from The
Rust Book as a reminder:

https://doc.rust-lang.org/book/ch07-04-bringing-paths-into-scope-with-the-use-keyword.html

Copy this attribute on top of main()

#[tokio::main]

For now, just understand that this attribute is supplied by the Tokio li
brary. It makes your async code signinifcantly simpler by allowing you 
not having to manually set up a runtime environment for async code.

Now that you have imported GameState into main.rs, you have acess to it's
methods and associated functions. Call the start_game method from the GameState
implementation onto game. Attach the await keyword after start_game() using
this syntax: 

.await?;

While .await looks like a method because of the . it's actually a keyword
used in async code. You can read more about the await keyword in the link
below, but it's ok if at this point you just understand that it's used with 
async code.

https://doc.rust-lang.org/std/keyword.await.html

Make the main function async, and have it return a Result type with the Ok var
iant as a unit type and Err variant as a String.

Why would we have main() return a Result type? Up until now, all of our 
programs looked like this:

fn main() {
//your program
}

Do you see that ? at the end of .await from earlier? The question mark sym
bol is a operator that handles error propagation. It unwraps the result if
it's Ok or returns the error back up the call stack if it's an Err

Finally, within main() finish the function with the Ok variant containing 
the unit type.

