In game_state.rs, create a public async method called start_game that
takes a mutable reference to self and returns a Result type where the
Ok variant is annotated with the Unit type and Err variant is annotated
with a String.

start_game is the main game logic runs continuously until the game
ends. In the body of start_game, what control-flow construct allows whatever
code inside of it to run continuously, over and over again?

Within the block of this control-flow construct, have the thread sleep for
10 milliseconds. HINT: notice use std::thread and use std::time::Duration
at the top of game_state.rs.

In the same block, call display_board() and close out your function. 
Note that additional functions will eventually go here, however.

If you aren't familiar with async, here's a starting resource:

https://rust-lang.github.io/async-book/

In "regular" code (also known as synchronous code), operations happen one
after another sequentially. 

Ex.: Function1 -> Function2 -> Function3.

But what if Function2 takes time to complete? It means the entire program has
has to wait until Function2 is done. This is a problem, in, say, a game. What
if Function2 job is to process user input, like when the player presses
the right arrow key, it moves him right? What happens if the player doesn't
press this key (for whatever reason)? It means the rest of the game would
freeze until he pressed a key. So enemies would freeze, music, and every
thing else. This is a problem.

Enter async code. Asynchronous code allows a program to perform non-blocking
operations. So instead of Function2 holding up the entire program, you could
say "Function2 when the player presses a key, wherever the program is currently at, it's going to register this key press and then run it's
associated logic, but until then the program will continue on with the rest of
it's functions."

OA:

    pub async fn start_game(&mut self) -> Result<(), String> {
        loop {
            thread::sleep(Duration::from_millis(10));
            self.display_board();
        }
    }
